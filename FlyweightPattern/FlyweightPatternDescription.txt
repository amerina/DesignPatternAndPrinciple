

享元模式（Flyweight Pattern）主要用于减少创建对象的数量,以减少内存占用和提高性能。

享元模式的原理
所谓“享元”,顾名思义就是被共享的单元。享元模式的意图是复用对象,节省内存,前提是享元对象是不可变对象。
具体来讲,当一个系统中存在大量重复对象的时候,我们就可以利用享元模式,将对象设计成享元,在内存中只保留一份实例,供多处代码引用,这样可以减少内存中对象的数量,以起到节省内存的目的。
实际上,不仅仅相同对象可以设计成享元,对于相似对象,我们也可以将这些对象中相同的部分（字段）,提取出来设计成享元,让这些大量相似对象引用这些享元


享元模式的实现
享元模式的代码实现非常简单,主要是通过工厂模式,在工厂类中,通过一个 Map 或者List 来缓存已经创建好的享元对象,以达到复用的目的


享元模式 vs 单例、缓存、对象池
我们前面也多次提到,区别两种设计模式,不能光看代码实现,而是要看设计意图,也就是要解决的问题。这里的区别也不例外

我们可以用简单几句话来概括一下它们之间的区别。
应用单例模式是为了保证对象全局唯一。
应用享元模式是为了实现对象复用,节省内存。
缓存是为了提高访问效率,而非复用。
池化技术中的"复用"理解为"重复使用",主要是为了节省时间



Participants
Flyweight Interface享元接口
	declares an interface through which flyweights can receive and act on extrinsic state. 


ConcreteFlyweight享元具体实现
	implements the Flyweight interface and adds storage for intrinsic state, if any. 
	A ConcreteFlyweight object must be sharable. Any state it stores must be intrinsic, that is, it must be independent of the ConcreteFlyweight object's context.

UnsharedConcreteFlyweight 
	not all Flyweight subclasses need to be shared. The Flyweight interface enables sharing, but it doesn't enforce it. 
	It is common for UnsharedConcreteFlyweight objects to have ConcreteFlyweight objects as children at some level in the flyweight object structure (as the Row and Column classes have). 


FlyweightFactory享元工厂
	creates and manages flyweight objects
	ensures that flyweight are shared properly. When a client requests a flyweight, the FlyweightFactory objects assets an existing instance or creates one, if none exists. 


Client
	maintains a reference to flyweight(s). 
	computes or stores the extrinsic state of flyweight(s). 


