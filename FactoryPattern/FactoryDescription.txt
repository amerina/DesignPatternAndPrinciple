

1.一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂

 简单工厂：一个工厂类，一个产品抽象类。
 优点:分离了实例的创建者和调用者，不让调用者直接去创建实例，而是通过工厂类去创建，明确了各自职责，有利于系统优化。
 缺点是:所有创建类的逻辑判断都放在工厂类中，如果需要创建新的类，那就只能去修改工厂类，这就违反了开闭原则，不应当修改底层类，应该通过拓展去加功能。

 工厂方法：多个工厂类，一个产品抽象类。
 优点:工厂方法模式把具体实例化的过程延伸到具体的工厂类中,解决了简单工厂模式中要新增类就得改工厂类代码的缺点,符合了开闭原则（对拓展开放，对修改封闭）。
 缺点:每新增一个类型，就得新增一个对应的工厂类，增加代码量

 抽象工厂：多个工厂类，多个产品抽象类。


2.当创建逻辑比较复杂,我们就考虑使用工厂模式,封装对象的创建过程,将对象的创建和使用相分离


第一种情况:类似规则配置解析的例子,代码中存在 if-else 分支判断,动态地根据不同的类型创建不同的对象。
针对这种情况，我们就考虑使用工厂模式,将if-else创建对象的代码抽离出来,放到工厂类中


第二种情况:
尽管我们不需要根据不同的类型创建不同的对象,但是单个对象本身的创建过程比较复杂,
比如前面提到的要组合其他类对象,做各种初始化操作.
在这种情况下,我们也可以考虑使用工厂模式,将对象的创建过程封装到工厂类中


对于第一种情况,
当每个对象的创建逻辑都比较简单的时候,推荐使用简单工厂模式,将多个对象的创建逻辑放到一个工厂类中。

当每个对象的创建逻辑都比较复杂的时候,为了避免设计一个过于庞大的简单工厂类,推荐使用工厂方法模式,将创建逻辑拆分得更细,每个对象的创建逻辑独立到各自的工厂类中。
同理,对于第二种情况,因为单个对象本身的创建逻辑就比较复杂,所以建议使用工厂方法模式



3.判断要不要使用工厂模式的最本质的参考标准：
	• 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
	• 代码复用：创建代码抽离到独立的工厂类之后可以复用。
	• 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
	• 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

4.优点： 
	1.一个调用者想创建一个对象，只要知道其名称就可以了。 
	2.扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
	3.屏蔽产品的具体实现，调用者只关心产品的接口。

  缺点：
  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖


5.Difference between Interface and Abstract


参考:
1.https://www.runoob.com/design-pattern
