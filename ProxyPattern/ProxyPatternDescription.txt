


代理,在其最一般的形式中,是一个类,作为其他事物的接口。 代理可以接口到任何东西: 网络连接、内存中的大对象、文件或其他开销很大或不可能复制的资源。 简而言之,代理是一个包装器或代理对象,客户机正在调用它来访问幕后的真正服务对象。 使用代理可以简单地转发到实际对象,或者可以提供额外的逻辑。 在代理中,可以提供额外的功能,例如,当对实际对象的操作资源密集时进行缓存,或者在调用对实际对象的操作之前检查前置条件。 
对于客户机来说,代理对象的使用类似于使用实际对象,因为两者实现相同的接口。


代理设计模式可以解决什么问题？
1、 对对象的访问应该受到控制
2、 在访问对象时应该提供附加功能
例如,在访问敏感对象时,应该可以检查客户端是否具有所需的访问权限。


代理设计模式描述了什么解决方案？
1、定义一个单独的 Proxy 对象
可以用作另一个对象的替代物(Subject)及 实现额外的功能,以控制对这个主题的访问
这使得可以通过 Proxy 对象来执行访问主题时的其他功能。 例如,若要检查访问敏感对象的客户端的访问权限,代理必须实现 Subject 接口。 客户无法分辨他们是与一个主题或其代理人合作。

可能的使用场景
	• Remote proxy 远程代理
	• Virtual proxy 虚拟代理(Lazy loading)
	• Protection proxy 保护代理:保护代理可用于基于访问权限控制对资源的访问。


所谓动态代理（Dynamic Proxy）,就是我们不事先为每个原始类编写代理类,而是在运行的时候,动态地创建原始类对应的代理类,然后在系统中用代理类替换掉原始类

RPC 框架
通过远程代理,将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候,就像使用本地函数一样,无需了解跟服务器交互的细节。除此之外,RPC 服务的开发者也只需要开发业务逻辑,就像开发本地使用的函数一样,不需要关注跟客户端的交互细节


代理模式的原理与实现
在不改变原始类（或叫被代理类）的情况下,通过引入代理类来给原始类附加功能。一般情况下,我们让代理类和原始类实现同样的接口。但是,如果原始类并没有定义接口,并且原始类代码并不是我们开发维护的。在这种情况下,我们可以通过让代理类继承原始类的方法来实现代理模式


动态代理的原理与实现
静态代理需要针对每个类都创建一个代理类,并且每个代理类中的代码都有点像模板式的"重复"代码,增加了维护成本和开发成本。对于静态代理存在的问题,我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类,而是在运行的时候动态地创建原始类对应的代理类,然后在系统中用代理类替换掉原始类


代理模式的应用场景
代理模式常用在业务系统中开发一些非功能性需求,比如：监控、统计、鉴权、限流、事务、幂等、日志。
我们将这些附加功能与业务功能解耦,放到代理类统一处理,让程序员只需要关注业务方面的开发。除此之外,代理模式还可以用在 RPC、缓存等应用场景中
